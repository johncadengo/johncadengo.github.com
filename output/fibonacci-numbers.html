<p><!doctype html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link href="markdown.css" type="text/css" rel="stylesheet"></link>
    <link href="prettify.css" type="text/css" rel="stylesheet"></link>
    <script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript" src="js/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="js/myscripts.js"></script>
    <title>Thousand Note - Fibonacci Numbers</title>
</head></p>

<p><body onload="styleCode()"></p>

<p><a href="index.html">Thousandnote</a></p>

<h1>Fibonacci Numbers</h1>

<p>Problem:</p>

<blockquote>
  <blockquote>
    <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
    
    <p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
    
    <p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
  </blockquote>
  
  <p>I'd like you to come up with 3 different solutions. The first has to be iterative. The second has to be recursive. And the last has to be efficient. Use the information you learn from the previous two solutions and any clues in the question to come up with a clever solution to the stated problem that has the fastest running time. If you can, time the three implementations and see if your optimizations are notable improvements.</p>
</blockquote>

<h2>Your solutions</h2>

<p>In Java,</p>

<pre><code>public static void iterativeway(){
    out.println("Iterative way:");
    int sum=2;
    int fib=0;
    int start1=1;
    int start2=2;
    out.println(start1);
    out.println(start2);
    while(start1+start2&lt;=max){
            fib=start1+start2;
            start1=start2;
            start2=fib;
            if(fib%2==0){
                sum+=fib;
            }

            out.println(fib);
    }

    out.println("Sum=" + sum);

}
public static void recursiveway(int x, int y, int sum){

    if(x==1 &amp;&amp; y==2)
    {
        out.println("Recursive way:");
        out.println(x);
        out.println(y);
    }
    if(x+y&gt;max)
    {
        out.println("Sum=" +sum);
    }
    else
    {
        if((x+y)%2==0)
        {
            sum+=(x+y);
        }
        out.println((x+y));
        recursiveway(y,x+y,sum);
    }

}
public static String efficientway()
{
    double x= (1+Math.sqrt(5.0))/2;
    double y= -(1/(x));

    out.println("Efficient way:");
    int fib=0;
    int i=3;
    int sum=0;
    while(fib&lt;max){
    sum+=fib;
    fib=(int) Math.round((((Math.pow(x,i)+ Math.pow(y, i))/(Math.sqrt(5.0)))));
    i+=3;
    }
    String total= "Sum=" +sum;
    return total;

}
</code></pre>

<p>These all work and come up with the right solution. 
The efficient way is good. You noticed or picked up
on an important pattern in the data, which is that
even fibonacci numbers only occur every third term.
This is because of this fact,</p>

<pre><code>Odd + Even = Even + Odd = Odd
Odd + Odd = Even
Even + Even = Even
</code></pre>

<p>Which is based on the properties of addition mod 2,</p>

<pre><code>(1 + 0) mod 2 = (0 + 1) mod 2 = 1 mod 2
(1 + 1) mod 2 = 2 mod 2 = 0 mod 2
(0 + 0) mod 2 = 0 mod 2
</code></pre>

<h2>And Your Main</h2>

<pre><code>public static void main(String[] args) throws IOException
    {

        out = new PrintStream("output.txt");

        starttime=System.currentTimeMillis();
        iterativeway();
        endtime=System.currentTimeMillis();
        out.println("Total iterative time =" + (endtime-starttime) +"ms");

        starttime=System.currentTimeMillis();
        recursiveway(1,2,2);
        endtime=System.currentTimeMillis();
        out.println("Total recursive time =" + (endtime-starttime)+"ms");

        starttime=System.currentTimeMillis();
        out.println(efficientway());
        endtime=System.currentTimeMillis();
        out.println("Total efficient time =" + (endtime-starttime)+"ms");

        out.println("test end");
    }
</code></pre>

<p>There are a few inefficiencies I'd like to address here. One of the major intentions
of <a href="http://en.wikipedia.org/wiki/Object_oriented_programming">object-oriented programming</a> 
is the idea of <a href="http://en.wikipedia.org/wiki/Code_reuse">code reuse</a>. In general, though
there are exceptions, you should not be copying and pasting major parts of your code. 
If there are parts of your code that look very similar save the names of certain variables
you should be thinking about how to refactor that code into a more reusable form.</p>

<h2>Python Solution</h2>

<pre><code>"""
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, â€¦

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

"""

def fib(n):
   """
   Naive recursive implemention for generating a fibonacci number.

   .. note::
      Will not work if n is too large. Must think of a better way.

      Must save past values and use them.

   """
   if n == 0 or n == 1: 
      # Base cases
      return n
   else:
      # Recursive call
      return fib(n-1) + fib(n-2)

def smartFib(n):
   """
   Smarter implementation of generating a fibonacci number.

   It saves past values and uses them to calculate future values.

   """
   l = [0, 1] # Base cases
   while l[-1] &lt; n:
      # Append a new value to the list made up of the last two values.
      l.append(l[-2] + l[-1]) 
   return l

def sumEvens(limit=4000000):
   """
   Naive approach to summing the even values below limit.

   .. note::
      We can use knowledge of the sequence to improve our calculation.

      1) Don't need to store all past values. Only need even values.
      2) Don't need to use mod to see if a value is even.
      3) Don't even need to store even values, can do a running sum.

   """
   l = smartFib(limit)
   evens = [e for e in l if e % 2 == 0]
   return sum(evens)

def test():
   """
   Make sure our answer for limit of 1,000,000 is 1089154.

   """
   assert sumEvens(1000000) == 1089154
   return "True"

if __name__ == '__main__':
   print __doc__
   print "Test successful:", test()
</code></pre>
