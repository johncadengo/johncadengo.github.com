<p><!doctype html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link href="markdown.css" type="text/css" rel="stylesheet"></link>
    <link href="prettify.css" type="text/css" rel="stylesheet"></link>
    <script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript" src="js/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="js/myscripts.js"></script>
    <title>Thousand Note - Fibonacci Numbers</title>
</head></p>

<p><body onload="styleCode()"></p>

<p><a href="index.html">Thousandnote</a></p>

<h1>Fibonacci Numbers</h1>

<p>Problem:</p>

<blockquote>
  <blockquote>
    <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
    
    <p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
    
    <p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
  </blockquote>
  
  <p>I'd like you to come up with 3 different solutions. The first has to be iterative. The second has to be recursive. And the last has to be efficient. Use the information you learn from the previous two solutions and any clues in the question to come up with a clever solution to the stated problem that has the fastest running time. If you can, time the three implementations and see if your optimizations are notable improvements.</p>
</blockquote>

<h2>Your solutions</h2>

<p>In Java,</p>

<pre><code>public static void iterativeway(){
    out.println("Iterative way:");
    int sum=2;
    int fib=0;
    int start1=1;
    int start2=2;
    out.println(start1);
    out.println(start2);
    while(start1+start2&lt;=max){
            fib=start1+start2;
            start1=start2;
            start2=fib;
            if(fib%2==0){
                sum+=fib;
            }

            out.println(fib);
    }

    out.println("Sum=" + sum);

}
public static void recursiveway(int x, int y, int sum){

    if(x==1 &amp;&amp; y==2)
    {
        out.println("Recursive way:");
        out.println(x);
        out.println(y);
    }
    if(x+y&gt;max)
    {
        out.println("Sum=" +sum);
    }
    else
    {
        if((x+y)%2==0)
        {
            sum+=(x+y);
        }
        out.println((x+y));
        recursiveway(y,x+y,sum);
    }

}
public static String efficientway()
{
    double x= (1+Math.sqrt(5.0))/2;
    double y= -(1/(x));

    out.println("Efficient way:");
    int fib=0;
    int i=3;
    int sum=0;
    while(fib&lt;max){
    sum+=fib;
    fib=(int) Math.round((((Math.pow(x,i)+ Math.pow(y, i))/(Math.sqrt(5.0)))));
    i+=3;
    }
    String total= "Sum=" +sum;
    return total;

}
</code></pre>

<p>These all work and come up with the right solution. 
The efficient way is good. You noticed or picked up
on an important pattern in the data, which is that
even fibonacci numbers only occur every third term.
This is because of this fact,</p>

<pre><code>Odd + Even = Even + Odd = Odd
Odd + Odd = Even
Even + Even = Even
</code></pre>

<p>Which is based on the properties of addition mod 2,</p>

<pre><code>(1 + 0) mod 2 = (0 + 1) mod 2 = 1 mod 2
(1 + 1) mod 2 = 2 mod 2 = 0 mod 2
(0 + 0) mod 2 = 0 mod 2
</code></pre>

<p>And only two of these cases occur in the traditional Fibonacci sequence.
Otherwise we'd be trapped, so to speak, among even numbers.</p>

<h2>And Your Main</h2>

<pre><code>public static void main(String[] args) throws IOException
    {

        out = new PrintStream("output.txt");

        starttime=System.currentTimeMillis();
        iterativeway();
        endtime=System.currentTimeMillis();
        out.println("Total iterative time =" + (endtime-starttime) +"ms");

        starttime=System.currentTimeMillis();
        recursiveway(1,2,2);
        endtime=System.currentTimeMillis();
        out.println("Total recursive time =" + (endtime-starttime)+"ms");

        starttime=System.currentTimeMillis();
        out.println(efficientway());
        endtime=System.currentTimeMillis();
        out.println("Total efficient time =" + (endtime-starttime)+"ms");

        out.println("test end");
    }
</code></pre>

<p>There are a few inefficiencies I'd like to address here. One of the major intentions
of <a href="http://en.wikipedia.org/wiki/Object_oriented_programming">object-oriented programming</a> 
is the idea of <a href="http://en.wikipedia.org/wiki/Code_reuse">code reuse</a>. In general, though
there are exceptions, you should not be copying and pasting major parts of your code. 
If there are parts of your code that look very similar save the names of certain variables
you should be thinking about how to refactor that code into a more reusable form.</p>

<p>Here is a simple refactoring of your code in pseudocode. There is probably more that could be done,</p>

<h2>Python Comparison</h2>

<p>Two ways to generate Fibonacci numbers I came up with real quick.</p>

<pre><code>def fib(n):
   """
   Naive recursive implemention for generating a fibonacci number.

   .. note::
      The stack gets overwhelmed if n is too large, and can crash the program.

   """
   if n == 0 or n == 1: 
      # Base cases
      return n
   else:
      # Recursive call
      return fib(n-1) + fib(n-2)

def smartFib(n):
   """
   Smarter implementation of generating a fibonacci number.

   It saves past values and uses them to calculate future values.

   """
   l = [0, 1] # Base cases
   while l[-1] &lt; n:
      # Append a new value to the list made up of the last two values.
      l.append(l[-2] + l[-1]) 
   return l
</code></pre>

<p>There are no sums being done here, but that can easily be added in. 
I give these two examples just to show the difference between recursive
and iterative calls. Your iterative solution is constantly swapping values,
this iterative solution saves them for future use. Both recursive calls
require vast amounts of memory and can be slow and costly to do. However,
note that the recursive call doesn't need both values <code>x</code> and <code>y</code> as
in your solution, but only <code>n</code> or the upper limit as in mine.</p>

<h2>Math</h2>

<p>A brilliant solution to the problem, which I found on a forum, is as follows,</p>

<pre><code>Phi (golden ratio) is the approximate ratio between
two consecutive terms in a Fibonacci sequence.
The ratio between consecutive even terms approaches
phi^3 (4.236068) because each 3rd term is even.
Use a calculator and round the results to the nearest
integer when calculating the next terms:

2,8,34,.. multiplying by 4.236068 each time: 144,610,
2584,10946,46368,196418 &amp; 832040

The sum is 1089154
</code></pre>

<p>Enjoy!</p>
